class l{#s=!0;#r=[];#a=10;silent(e){typeof e!="boolean"&&this.#i("silent","silent-boolean"),this.#s=e}isSilent(){return this.#s}#h(e,i,r,t){let s,a={"input-check":100,"invalid-check":101,"invalid-option":102,"array-option":103,"object-range":105,"from-missing":106,"to-missing":107,"number-from":108,"number-to":109,"silent-boolean":110,"min-value":111,"check-fail":200,"option-fail":201,"range-fail":202,"range-type":203};return s={100:`Error: (${e}) Missing data type.`,101:`Error: (${e}) Invalid data type. See the docs.`,102:`Error: (${e}) Invalid value. See the docs.`,103:`Error: (${e}) Expected an array.`,105:`Error: (${e}) Expected an object with "from" and "to".`,106:`Error: (${e}) Key "from" is missing.`,107:`Error: (${e}) Key "to" is missing.`,108:`Error: (${e}) "from" must be a number.`,109:`Error: (${e}) "to" must be a number.`,110:`Error: (${e}) Expected a boolean.`,111:`Error: (${e}) Must be a number greater than or equal to 1.`,200:`Check failed: (${e}) Type mismatch. Expected "${r}", got "${t}".`,201:`Check failed: (${e}) Value "${r}" not found.`,202:`Check failed: (${e}) Value "${r}" is out of range.`,203:`Check failed: (${e}) Only "number" or "bigint" allowed.`}[a[i]],s}#l(e,i,r,t){let s,a;const n=this.#n(t);if(n!==!1?s=n:s=(typeof t).charAt(0).toUpperCase()+(typeof t).slice(1),a=this.#h(e,i,r,s),a=`${a} - ${new Date().toISOString()}`,this.#r.length>=this.#a)for(let h=this.#r.length;h>=this.#a;h--)this.#r.shift();this.#r.push(a)}#e(e,i,r,t){if(this.#l(e,i,r,t),this.#s===!0)return!1;this.#f(e,i,r,t)}#i(e,i,r,t){this.#l(e,i,r,t),this.#f(e,i,r,t)}#f(e,i,r,t){let s;const a=this.#n(t);throw a!==!1?s=a:s=(typeof t).charAt(0).toUpperCase()+(typeof t).slice(1),new Error(this.#h(e,i,r,s))}#o(e){return typeof e=="number"&&isNaN(e)?this.#e("check","check-fail","Number",e):e===1/0||e===-1/0?this.#e("check","check-fail","Number",e):typeof e!="number"?this.#e("check","check-fail","Number",e):!0}#u(e){return typeof e!="string"?this.#e("check","check-fail","String",e):!0}#c(e){return typeof e!="boolean"?this.#e("check","check-fail","Boolean",e):!0}#y(e){return typeof e!="bigint"?this.#e("check","check-fail","BigInt",e):!0}#b(e){return typeof e<"u"?this.#e("check","check-fail","Undefined",e):!0}#k(e){return e!==null?this.#e("check","check-fail","Null",e):!0}#p(e){return typeof e!="symbol"?this.#e("check","check-fail","Symbol",e):!0}#m(e){return Array.isArray(e)?!0:this.#e("check","check-fail","Array",e)}#d(e){return typeof e!="object"||e===null||Array.isArray(e)?this.#e("check","check-fail","Object",e):!0}#n(e){return Array.isArray(e)?"Array":e===null?"Null":e===1/0?"Infinity":e===-1/0?"-Infinity":typeof e=="number"&&isNaN(e)?"NaN":typeof e=="bigint"?"BigInt":!1}check(e,i){i==null&&this.#i("check","input-check");let r;const t=i.toLowerCase();switch(["number","string","boolean","bigint","undefined","null","symbol","array","object"].includes(t)||this.#i("check","invalid-check"),t){case"number":r=this.#o(e);break;case"string":r=this.#u(e);break;case"boolean":r=this.#c(e);break;case"bigint":r=this.#y(e);break;case"undefined":r=this.#b(e);break;case"null":r=this.#k(e);break;case"symbol":r=this.#p(e);break;case"array":r=this.#m(e);break;case"object":r=this.#d(e);break}return r}checkOptions(e,i){const r=["string","number","bigint","boolean","Infinity","-Infinity"];return!r.includes(typeof e)&&!r.includes(e)&&this.#i("checkOptions","invalid-option"),typeof e=="number"&&isNaN(e)&&this.#i("checkOptions","invalid-option"),Array.isArray(i)||this.#i("checkOptions","array-option"),i.includes(e)?!0:this.#e("checkOptions","option-fail",e)}#t(e){return!!(typeof e!="bigint"&&typeof e!="number"||typeof e=="number"&&isNaN(e))}checkRange(e,i){return this.#t(e)?this.#e("checkRange","range-type"):(typeof i!="object"&&this.#i("checkRange","object-range"),Object.keys(i).includes("from")||this.#i("checkRange","from-missing"),Object.keys(i).includes("to")||this.#i("checkRange","to-missing"),this.#t(i.from)&&this.#i("checkRange","number-from"),this.#t(i.to)&&this.#i("checkRange","number-to"),e<i.from||e>i.to?this.#e("checkRange","range-fail",e):!0)}getLastError(){return this.#r[this.#r.length-1]}maxErrorSize(e){this.#t(e)&&this.#i("maxErrorSize","min-value"),e<1&&this.#i("maxErrorSize","min-value"),this.#a=e}getErrors(){return this.#r}getType(e){let i,r=this.#n(e);return r!==!1?i=r:i=typeof e,i=i.toLowerCase(),i}}const f=new l;export{l as Validate};export default f;
